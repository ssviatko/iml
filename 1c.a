	!to "1c.o",plain
	!cpu 65816

	*= $0000

IO_KEYQ_SIZE = $1bfc00
IO_KEYQ_WAITING = $1bfc01
IO_KEYQ_DEQUEUE = $1bfc02
IO_KEYQ_CLEAR = $1bfc03

IO_CON_CLS = $1bfc10
IO_CON_COLOR = $1bfc11
IO_CON_CHAROUT = $1bfc12
IO_CON_REGISTER = $1bfc13
IO_CON_CURSORH = $1bfc14;
IO_CON_CURSORV = $1bfc15;
IO_CON_CURSOR = $1bfc16;
IO_CON_CR = $1bfc17

IO_VIDMODE = $1bfc20

promptchar = '>'

l_getline = $1c0000 + getline
l_prinbuff = $1c0000 + prinbuff
l_prcdpla = $1c0000 + prcdpla
l_ucline = $1c0000 + ucline

alarge = $2d
xlarge = $2e
scratch1 = $2f
enterbytes = $30
enterbytes_m = $31
enterbytes_h = $32
rangehigh = $33
monrange = $35
monlast = $36
parseptr = $37
parseptr_m = $38
parseptr_h = $39
mondump = $3a
mondump_m = $3b
mondump_h = $3c
dpla = $3d
dpla_m = $3e
dpla_h = $3f

inbuff = $170400

x1crominit
	phk
	plb
	rep #$10
	!rl
	sep #$20
	!as
	ldx #initstring
	stx dpla
	lda #$1c
	sta dpla_h
	jsl l_prcdpla
	jmp+2 monstart

parse_setup
	ldx #$0400
	stx parseptr
	lda #$17
	sta parseptr_h
	rts
	
	!zone parse_getchar
parse_getchar			;get char from inbuff, assumes 8 bit A, 16 bit X
	lda [parseptr]
	pha
	inc parseptr
	bne .local2
	inc parseptr_m
	bne .local2
	inc parseptr_h
.local2
	pla
	rts
	
	!zone parse_addr
parse_addr				;see if user specified an address on line.
	lda #$00
	pha
	pha					;make space for working value on the stack
	sta monrange		;clear range flag
.throwaway
	jsr+2 parse_getchar
	cmp #' '
	beq .throwaway		;throw away leading spaces
	jsr+2 parse_getnib2	;get first nibble. call 2nd entry point since we already have character
	bcc .no				;didn't even get one hex character, so return false
	sta 1,s				;save it on the stack for now
	jsr+2 parse_getnib	;get second nibble
	bcc .yes			;if not hex then bail
	pha
	lda 2,s
	asl
	asl
	asl
	asl
	ora 1,s
	sta 2,s
	pla					;add to stack
	jsr+2 parse_getnib	;get possible third nibble
	bcc .yes
	rep #$30			;we're dealing with a 16 bit value now
	!al
	and #$000f
	pha
	lda 3,s
	asl
	asl
	asl
	asl
	ora 1,s
	sta 3,s
	pla
	sep #$20
	!as
	jsr+2 parse_getnib
	bcc .yes
	rep #$30
	!al
	and #$000f
	pha
	lda 3,s
	asl
	asl
	asl
	asl
	ora 1,s
	sta 3,s
	pla
	sep #$20			;fall thru to yes on 4th nibble
	!as
	jsr parse_getchar	;check to see if next char is a . so we can specify ranges
	cmp #'.'
	bne .yes
	lda #$80
	sta monrange
.yes
	ply					;get 16 bit work address off of stack
	sec					;got address, return
	rts
.no
	ply					;clear stack
	clc					;no address found, return
	rts
parse_getnib
	jsr parse_getchar
parse_getnib2			;enter here after we've thrown away leading spaces
	cmp #' '
	beq .outrng			;space = end of value
	cmp #'.'
	bne .notrange
	lda #$80
	sta monrange		;this is the start of a range specification
	clc
	rts
.notrange
	cmp #$41
	bcc .outrnga
	cmp #$47
	bcs .outrnga
	sec
	sbc #$07			;in range of A-F
.success
	and #$0f
	sec
	rts
.outrnga				;test if 0-9
	cmp #$30
	bcc .outrng
	cmp #$3a
	bcc .success		;less than 3a, but >= 30, else fall thru to outrng
.outrng
	clc
	rts
	
prdumpaddr
	lda mondump_h			;print long address
	jsr+2 prhex
	lda #'/'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	ldx mondump
	jsr+2 prhex16
	lda #'-'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	rts
	
adjdumpaddr					;add 8 to dump address
	rep #$30
	!al
	lda mondump
	clc
	adc #$0008
	sta mondump
	sep #$20
	!as
	php						;save carry state.. did we carry to the bank?
	lda mondump_h
	adc #$00
	sta mondump_h
	plp
	rts
	
bankcmd
	jsr parse_addr
	bcc monerror
	tya
	sta mondump_h
	jmp moncmd
monerror
	ldx #monsynerr
	stx dpla
	lda #$1c
	sta dpla_h
	jsl l_prcdpla
	jmp moncmd
monsynerr
	!tx "Syntax error!"
	!byte $0d, $00

colorcmd
	jsr parse_addr
	bcc monerror
	tya
	sta IO_CON_COLOR
	jmp moncmd
	
modecmd
	jsr parse_addr
	bcc monerror
	tya
	cmp #$08
	bcc monerror
	cmp #$0a
	bcs monerror
	sta IO_VIDMODE
	lda #$00
	sta IO_CON_CURSORH
	sta IO_CON_CURSORV
	lda #$20
	sta IO_CON_CHAROUT
	sta IO_CON_CLS
	jmp moncmd
	
monstart				;main entry point for system monitor
	phk
	plb
	rep #$10
	!rl
	sep #$20
	!as
	ldx #$0000
	stx mondump
	lda #$1c
	sta mondump_h
	lda #'D'
	sta monlast
	
	!zone moncmd
moncmd
	lda #promptchar
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	jsl l_getline
	jsl l_ucline
	jsr parse_setup
	jsr parse_getchar
.local3
	cmp #'Q'
	beq haltcmd
	cmp #'D'
	bne .local4
	jmp+2 dumpcmd
.local4
	cmp #$0d
	bne .local2
	lda monlast			;recall previously executed command
	cmp #$20			;make sure it isn't a control character
	bcs .local3			;and retry it
	bra moncmd			;else recycle and try a new command
.local2
	cmp #'A'
	beq asciidumpcmd
	cmp #'B'
	bne .local5
	jmp+2 bankcmd
.local5
	cmp #'C'
	bne .local6
	jmp+2 colorcmd
.local6
	cmp #'M'
	bne .local7
	jmp+2 modecmd
.local7
	cmp #'E'
	bne .local8
	jmp+2 entercmd
.local8
	cmp #'L'
	bne .local9
	jmp+2 listcmd
.local9
	cmp #'?'
	beq helpcmd
	jmp moncmd
	
helpcmd
	ldx #helpmsg
	stx dpla
	lda #$1c
	sta dpla_h
	jsl l_prcdpla
	jmp moncmd
	
haltcmd
	ldx #haltmsg
	stx dpla
	lda #$1c
	sta dpla_h
	jsl l_prcdpla
	stp
haltmsg
	!tx "Halting 65816 engine.."
	!byte $0d,$00
	
	!zone asciidumpcmd
asciidumpcmd
	sta monlast
	jsr parse_addr
	bcc .local3
	sty mondump
	sty rangehigh
	bit monrange			;user asking for a range?
	bpl .local3
	jsr parse_addr			;get the remaining half of the range
	sty rangehigh
	lda #$80				;replace value in monrange since parse_addr will overwrite it
	sta monrange
	ldy rangehigh
	bne .local6
	jmp+2 monerror			;top of range can't be zero
.local6
	ldy mondump
	cpy rangehigh
	bcc .local3				;mondump must be less than rangehigh or it's a syntax error
	jmp+2 monerror
.local3
	jsr prdumpaddr
	ldy #$0000
.local2
	lda [mondump],y
	cmp #$20
	bcs .local4
	lda #'.'				;substitute control character with a period
.local4
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	iny
	lda IO_VIDMODE
	cmp #$09
	bne .lores1
	cpy #$0040
	bne .local2
	bra .lores2
.lores1
	cpy #$0010
	bne .local2
.lores2
	sta IO_CON_CR
	jsr adjdumpaddr
	bcs .local5				;carry to bank, exit even if we're processing a range
	jsr adjdumpaddr
	bcs .local5	
	lda IO_VIDMODE
	cmp #$09
	bne .lores3
	jsr adjdumpaddr
	bcs .local5	
	jsr adjdumpaddr
	bcs .local5	
	jsr adjdumpaddr
	bcs .local5	
	jsr adjdumpaddr
	bcs .local5	
	jsr adjdumpaddr
	bcs .local5	
	jsr adjdumpaddr
	bcs .local5	
.lores3
	bit monrange			;ranges on?
	bpl .local5
	ldy rangehigh
	cpy mondump
	bcs .local3
.local5
	stz monrange
	jmp moncmd
	
	!zone dumpcmd
dumpcmd
	sta monlast
	jsr parse_addr
	bcc .local3
	sty mondump				;if address was specified, store 16 bit y at low 16 bits of mondump address
	sty rangehigh
	bit monrange			;user asking for a range?
	bpl .local3
	jsr parse_addr			;get the remaining half of the range
	sty rangehigh
	lda #$80				;replace value in monrange since parse_addr will overwrite it
	sta monrange
	ldy rangehigh
	bne .local6
	jmp+2 monerror			;top of range can't be zero
.local6
	ldy mondump
	cpy rangehigh
	bcc .local3				;mondump must be less than rangehigh or it's a syntax error
	jmp+2 monerror
.local3
	jsr prdumpaddr
	ldy #$0000
.local2
	lda [mondump],y
	jsr+2 prhex
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	iny
	lda IO_VIDMODE
	cmp #$09
	bne .lores1
	cpy #$0010
	bne .local2
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'-'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	ldy #$0000				;print 16 bytes as ASCII... bonus when in mode 9!
.asc2
	lda [mondump],y
	cmp #$20
	bcs .asc4
	lda #'.'				;substitute control character with a period
.asc4
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	iny
	cpy #$0010
	bne .asc2
	bra .lores2
.lores1
	cpy #$0008
	bne .local2
.lores2
	sta IO_CON_CR
	jsr adjdumpaddr
	bcs .local5				;carry to bank, exit even if we're processing a range
	lda IO_VIDMODE
	cmp #$09
	bne .lores3
	jsr adjdumpaddr
	bcs .local5
.lores3
	bit monrange			;ranges on?
	bpl .local5
	ldy rangehigh
	cpy mondump
	bcc .local5
	jmp+2 .local3
.local5
	stz monrange
	jmp moncmd
	
prhex16
	rep #$30
	txa
	sep #$20
	xba
	jsr+2 prhex
	xba
prhex
	pha
	lsr
	lsr
	lsr
	lsr
	jsr+2 prhexnib
	pla
	and #$0f
prhexnib
	ora #$30
	cmp #$3a
	bcc prhexnofix
	clc
	adc #$07
prhexnofix
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	rts

	!zone entercmd
.local1
	jmp monerror
entercmd
	jsr parse_addr
	bcc .local1			;address is mandatory
	bit monrange
	bmi .local1			;ranges not allowed
	sty enterbytes
	lda mondump_h
	sta enterbytes_h	;retrieve bank from mondump
.local2
	jsr parse_addr		;start grabbing bytes
	bcc .enterdone
	bit monrange
	bmi .local1			;stop that happening here too
	rep #$30
	tya
	sep #$20			;get low byte of parsed address into A
	sta [enterbytes]
	inc enterbytes
	bne .local3
	inc enterbytes_m
	bne .local3
	inc enterbytes_h
.local3
	bra .local2
.enterdone
	jmp moncmd
	
	!zone listcmd
listcmd
	jsr parse_addr
	bcc .listmany				;address is optional
	sty mondump
.listmany
	lda IO_VIDMODE
	cmp #$09
	bne .listmany1
	ldx #32
	bra .listmany2
.listmany1
	ldx #15
.listmany2
	phx
	jsr+2 .listsingle
	plx
	dex
	bne .listmany2
	jmp moncmd
.listsingle
	ldy #$0000
	jsr prdumpaddr
	lda #$00
	xba					;clear B
	lda [mondump]				;get opcode
	cmp #$a
	bcc .dunno2
	jmp .dunno
.dunno2
	pha					;save opcode
	tax
	lda mnemlenmode,x
	lsr
	lsr
	lsr
	lsr					;isolage opcode len
	sta scratch1
	lda [mondump]
	jsr+2 is816
	lda scratch1
	tax
	ldy #$0000
.nextbyte
	lda [mondump],y
	jsr prhex			;print hex
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER	;print space
	iny
	dex
	bne .nextbyte
	lda #$18
	sta IO_CON_CURSORH	;tab over
	pla					;get opcode back
	tax
	lda mnemlist,x
	phx					;stash our opcode
	asl
	clc
	adc mnemlist,x		;multiply by 3
	tax
	lda mnems, x
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	inx
	lda mnems, x
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	inx
	lda mnems, x
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #' '
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	plx					;get our opcode back in index
	lda mnemlenmode,x
	and #$0f			;isolate the addressing mode
	asl					;multiply by two
	tax
	jsr (listamod,x)
	sta IO_CON_CR
.fixup
	lda scratch1		;get our fixup
	clc
	adc mondump
	sta mondump
	lda mondump_m
	adc #$00
	sta mondump_m
	lda mondump_h
	adc #$00
	sta mondump_h
.goback
	rts
.dunno
	jsr prhex
	lda #$18
	sta IO_CON_CURSORH
	lda #$01
	sta scratch1		;fix up one byte
	lda #'?'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	sta IO_CON_REGISTER
	sta IO_CON_REGISTER
	sta IO_CON_CR
	bra .fixup

amod0
	lda #'$'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	ldy #$0001
	lda [mondump],y
	jsr prhex
	rts
amod1
	lda #'('
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'$'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	ldy #$0001
	lda [mondump],y
	jsr prhex
	lda #','
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'X'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #')'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	rts
amod2
	ldy #$0001
	lda [mondump],y
	jsr prhex
	lda #','
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'S'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	rts
amod3
	lda #'['
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'$'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	ldy #$0001
	lda [mondump],y
	jsr prhex
	lda #']'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
amod4
	rts
	!zone amod5
amod5
	lda #'#'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda #'$'
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	lda scratch1
	cmp #$02
	beq .amod508
.amod516
	ldy #$0002
	lda [mondump],y
	jsr prhex
.amod508
	ldy #$0001
	lda [mondump],y
	jsr prhex
	rts
	
	!zone is816
is816
	pha
	and #$1f
	cmp #$09				;09, 29, 49, etc?
	bne .testx
	bit alarge				;16 bit?
	bmi .is16
	bpl .is8
.testx
	cmp #$a0
	beq .isx
	cmp #$a2
	beq .isx
	cmp #$c0
	beq .isx
	cmp #$e0
	beq .isx
	pla						;made it here, not an accumulator or index instruction
	rts
.isx
	bit xlarge
	bmi .is16				;or else fall thru
.is8
	lda #$2
	sta scratch1
	pla
	rts
.is16
	lda #$3
	sta scratch1
	pla
	rts
	
listamod
	!16 amod0
	!16 amod1
	!16 amod2
	!16 amod3
	!16 amod4
	!16 amod5
	
mnemlenmode
	!byte %00100000		;00 brk 2/$xx
	!byte %00100001		;01 ora 2/($xx,x)
	!byte %00100000		;02 cop 2/$xx
	!byte %00100010		;03 ora 2/x,s
	!byte %00100000		;04 tsb 2/$xx
	!byte %00100000		;05 ora 2/$xx
	!byte %00100000		;06 asl 2/$xx
	!byte %00100011		;07 ora 2/[$xx]
	!byte %00010100		;08 php 1
	!byte %00100101		;09 ora 2/#imm
mnemlist
	!byte $00			;00 brk
	!byte $02			;01 ora
	!byte $01			;02 cop
	!byte $02			;03 ora
	!byte $03			;04 tsb
	!BYTE $02			;05 ora
	!byte $04			;06 asl
	!byte $02			;07 ora
	!byte $05			;08 php
	!byte $02			;09 ora
mnems
	!tx "BRK"
	!tx "COP"
	!tx "ORA"
	!tx "TSB"
	!tx "ASL"
	!tx "PHP"
	!tx "PHD"
	
	!zone ucline
ucline					;convert inbuff at $170400 to upper case
	php
	rep #$10
	sep #$20
	!as
	!rl
	ldx #$0000
.local2
	lda inbuff,x
	beq .local4			;hit the zero, so bail
	cmp #'a'
	bcc .local3			;less then lowercase a, so ignore
	cmp #'z' + 1		;less than next character after lowercase z?
	bcs .local3			;greater than or equal, so ignore
	sec
	sbc #('z' - 'Z')	;make upper case
	sta inbuff,x
.local3
	inx
	bra .local2
.local4
	plp
	rtl
	
	!zone getline
getline
	php
	rep #$10
	sep #$20
	!as
	!rl
	ldx #$0000
.local2
	lda IO_KEYQ_SIZE
	beq .local2
	lda IO_KEYQ_WAITING
	sta IO_KEYQ_DEQUEUE
	cmp #$0d			;carriage return yet?
	beq .local3
	cmp #$08			;backspace/back arrow?
	beq .local4
	cmp #$20 			;generally any control character besides what we're specifically looking for?
	bcc .local2		 		;yes, so ignore it
	sta inbuff,x 		;any other character, so register it and store it
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	inx
	lda #$0d			;tee up a CR just in case we have to fall thru below
	cpx #$3fe			;overrun end of buffer yet?
	bne .local2			;no, so get another char.. otherwise fall thru
.local3
	sta inbuff,x		;store CR
	sta IO_CON_CR
	inx
	lda #$00			;store zero to end it all
	sta inbuff,x
	plp
	rtl
.local4
	cpx #$0000
	beq .local2			;no data in buffer yet, so nothing to backspace over
	lda #$08
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER	;print backspace char, which backs up the cursor
	lda #$20
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER	;blot out the character with a space
	lda #$08
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER	;print backspace char again since we advanced the cursor
	dex
	bra .local2
	
prinbuff				;feed location of input buffer into dpla and then print
	php
	rep #$10
	sep #$20
	!as
	!rl
	lda #$17
	sta dpla_h
	lda #$04
	sta dpla_m
	stz dpla
	jsl l_prcdpla
	plp
	rtl
	
	!zone prcdpla
prcdpla					; print C string pointed to by dp locations $3d-$3f
	php
	rep #$10
	sep #$20
	!as
	!rl
	ldy #$0000
.local2
	lda [dpla],y
	beq .local3
	sta IO_CON_CHAROUT
	sta IO_CON_REGISTER
	iny
	bra .local2
.local3
	plp
	rtl

initstring
	!tx "IML 65816 1C Firmware v00"
	!byte 0x0d
	!tx "System Monitor"
	!byte 0x0d
	!byte 0x0d
	!byte 0

helpmsg
	!tx "IML 65816 Monitor Commands"
	!byte $0d
	!tx "A <addr>  Dump ASCII"
	!byte $0d
	!tx "B <bank>  Change bank"
	!byte $0d
	!tx "C <color> Change terminal colors"
	!byte $0d
	!tx "D <addr>  Dump hex"
	!byte $0d
	!tx "E <addr> <byte> <byte>...  Enter bytes"
	!byte $0d
	!tx "L <addr>  Disassemble 65816 Instructions"
	!byte $0d
	!tx "M <mode>  Change video mode, 8/9"
	!byte $0d
	!tx "Q         Halt the processor"
	!byte $0d
	!tx "?         This menu"
	!byte $0d
	!tx "<enter>   Repeat last dump command"
	!byte $0d
	!tx "To specify range, use <addr1.addr2>"
	!byte $0d, 00
	
!align $ffff, $ffff,$00	;fill up to top of memory

